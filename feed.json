{
    "version": "https://jsonfeed.org/version/1",
    "title": "Tin&#x27;s Blog",
    "description": "",
    "home_page_url": "https://tinpham231.github.io/gh-pages",
    "feed_url": "https://tinpham231.github.io/gh-pages/feed.json",
    "user_comment": "",
    "author": {
        "name": "Pham Ba Tin"
    },
    "items": [
        {
            "id": "https://tinpham231.github.io/gh-pages/oop-trong-javascript-co-gi-khac-voi-ngon-ngu-khac.html",
            "url": "https://tinpham231.github.io/gh-pages/oop-trong-javascript-co-gi-khac-voi-ngon-ngu-khac.html",
            "title": "OOP Trong Javascript Có Gì Khác Với Ngôn Ngữ Khác?",
            "summary": "Trước khi đọc bài viết này, bạn nên ôn lại kiến thức về object và prototype trong Javacript. Trước khi phân tích về OOP trong JavaScript, mình sẽ nhắc lại sơ 1 số tính chất trong OOP. Trong lập trình hướng đối tượng (OOP) có 4 tính chất là tính đóng gói&hellip;",
            "content_html": "<p><strong>Trước khi đọc bài viết này, bạn nên ôn lại kiến thức về <a href=\"https://codelearn.io/sharing/object-trong-javascript\" target=\"_blank\" rel=\"noopener\">object</a> và <a href=\"https://codelearn.io/sharing/prototype-trong-javascript\" target=\"_blank\" rel=\"noopener\">prototype</a> trong Javacript. Trước khi phân tích về OOP trong JavaScript, mình sẽ nhắc lại sơ 1 số tính chất trong OOP.</strong></p>\n<h3>Các tính chất của OOP</h3>\n<p><img loading=\"lazy\" src=\"https://s3-sgn09.fptcloud.com/codelearnstorage/Media/Default/Users/Khoaa/Image/object-oriented-programming-features.png\" data-is-external-image=\"true\"></p>\n<p>Trong lập trình hướng đối tượng (OOP) có 4 tính chất là tính đóng gói (<em>Encapsulation</em>), tính kế thừa (<em>Inheritance</em>), tính đa hình (<em>Polymorphism</em>) và tính trừu tượng (<em>Abstraction</em>)</p>\n<h3>1. <strong>Encapsulation (Tính đóng gói):</strong></h3>\n<p>Tính đóng là kỹ thuật giúp bạn che giấu được những thông tin bên trong đối tượng. Mục đích chính của tính đóng gói là giúp hạn chế các lỗi khi phát triển chương trình. Tính chất này không cho phép người sử dụng các đối tượng thay đổi trạng thái nội tại của một đối tượng. Chỉ có các phương thức nội tại của đối tượng cho phép thay đổi trạng thái của nó. Việc cho phép môi trường bên ngoài tác động lên các dữ liệu nội tại của một đối tượng theo cách nào là hoàn toàn tùy thuộc vào người viết mã. Đây là tính chất đảm bảo sự toàn vẹn của đối tượng.</p>\n<p>Các lợi ích chính mà tính đóng gói mang lại:</p>\n<ul>\n<li>Hạn chế được các truy xuất không hợp lệ tới các thuộc tính của đối tượng.</li>\n<li>Giúp cho trạng thái của đối tượng luôn đúng.</li>\n<li>Giúp ẩn đi những thông tin không cần thiết về đối tượng.</li>\n<li>Cho phép bạn thay đổi cấu trúc bên trong lớp mà không ảnh hưởng tới lớp khác. </li>\n</ul>\n<h3><strong>2. Inheritance(Tính kế thừa):</strong></h3>\n<p>Kế thừa trong lập trình hướng đối tượng chính là thừa hưởng lại những thuộc tính và phương thức của một lớp. Có nghĩa là nếu lớp A kế thừa lớp B thì lớp A sẽ có những thuộc tính và phương thức của lớp B. Lớp được thừa hưởng những thuộc tính và phương thức từ lớp khác được gọi là dẫn xuất (<em>Derived Class</em>) hay lớp Con (<em>Subclass</em>) và lớp bị lớp khác kế thừa được gọi là lớp cơ sở (<em>Base Class</em>) hoặc lớp cha (<em>Parent Class</em>). </p>\n<p>Các lợi ích của tính kế thừa:</p>\n<ul>\n<li>Giúp tái sử dụng lại code.</li>\n<li>Tăng khả năng mở rộng của chương trình.</li>\n</ul>\n<h3><strong>3. Polymorphism(Tính đa hình):</strong></h3>\n<p>Tính đa hình thể hiện thông qua việc gửi các thông điệp (message). Việc gửi các thông điệp này có thể so sánh như việc gọi các hàm bên trong của một đối tượng. Các phương thức dùng trả lời cho một thông điệp sẽ tùy theo đối tượng mà thông điệp đó được gửi tới sẽ có phản ứng khác nhau. Người lập trình có thể định nghĩa một đặc tính (chẳng hạn thông qua tên của các phương thức) cho một loạt các đối tượng gần nhau nhưng khi thi hành thì dùng cùng một tên gọi mà sự thi hành của mỗi đối tượng sẽ tự động xảy ra tương ứng theo đặc tính của từng đối tượng mà không bị nhầm lẫn.</p>\n<h3><strong>4. Abstraction(Tính trừu tượng):</strong></h3>\n<p>Tính trừu tượng là một tính chất mà chỉ tập trung vào những tính năng của đối tượng và ẩn đi những thông tin không cần thiết. Tính chất này giúp bạn trọng tâm hơn vào những tính năng thay vì phải quan tâm tới cách mà nó được thực hiện. </p>\n<p><strong>Trong phạm vi bài viết này, chúng ta sẽ bàn về 3 đặc tính của OOP (tính đóng gói, tính kế thừa, tính đa hình), so sánh cách hiện thực chúng trong Java và JavaScript.</strong></p>\n<h3><strong>OOP trong Java</strong></h3>\n<p>Như các bạn đã biết, <strong>Java</strong> là một ngôn ngữ hướng đối tượng, do đó việc hiện thực các đặc tính <strong>OOP</strong> rất đơn giản và nhanh gọn, dễ hiểu.</p>\n<h3><strong>1. Tính đóng gói</strong></h3>\n<p>Tính bao đóng trong <strong>Java</strong> thể hiện bằng cách để phạm vi truy cập của các thuộc tính là <code>private</code> và truy xuất tới các thuộc tính này thông qua phương thức <code>public</code> (gọi là các <code>setter</code>, <code>getter</code>).</p>\n<p><strong>Ví dụ:</strong></p>\n<pre class=\"language-javascript\"><code>class Student {\n   private String name;\n   private int age;\n   private double gpa;\n\n   public String getName() {\n      return name;\n   }\n\n   public void setName(String name) {\n      this.name = name;\n   }\n\n   public int getAge() {\n      return age;\n   }\n\n   public void setAge(int age) {\n      this.age = age;\n   }\n\n   public double getGpa() {\n      return gpa;\n   }\n\n   public void setGpa(double gpa) {\n      this.gpa = gpa;\n   }\n\n}</code></pre>\n<p>Với cách làm này thông tin của đối tượng đã được ẩn đi, bạn chỉ có thể giao tiếp với đối tượng thông qua các phương thức. Điều này cũng giống với thực tế. Ví dụ khi bạn gặp một người lạ thì bạn không thể biết được các thuộc tính của người này (số điện thoại, sở thích, ...), kể cả khi bạn hỏi thì người này cũng chưa chắc đã trả lời cho bạn đúng sự thật (giống như phương thức không trả về giá trị thực thuộc tính mà trả về một giá trị khác).</p>\n<h3><strong>2. Tính kế thừa</strong></h3>\n<p>Trong <strong>Java</strong>, để kế thừa một lớp bạn dùng từ khóa <code>extends</code>.</p>\n<p><strong>Ví dụ:</strong></p>\n<pre class=\"language-java\" tabindex=\"0\"><code>class Person {\n   private String name;\n   private int age;\n\n   public void setName(String name) {\n      this.name = name;\n   }\n\n   public String getName() {\n      return name;\n   }\n\n   public void setAge(int age) {\n      this.age = age;\n   }\n\n   public int getAge() {\n      return age;\n   }\n}\n\nclass Student extends Person {\n   private double gpa;\n   \n   public void setGpa(double gpa) {\n      this.gpa = gpa;\n   }\n\n   public double getAge() {\n      return gpa;\n   }\n}\n\nclass Entry {\n   public static void main(String[] args) {\n      Student s = new Student();\n      s.setName(\"Khoa\");\n      s.setAge(19);\n      s.setGpa(10); \n      System.out.println(\"Name: \" + s.getName());\n      System.out.println(\"Age: \" + s.getAge());\n      System.out.println(\"GPA: \" + s.getGpa());\n   }\n}</code></pre>\n<p>Kết quả khi chạy chương trình:</p>\n<pre class=\"language-markup\" tabindex=\"0\"><code>Name: Khoa\nAge: 19\nGPA: 10.0</code></pre>\n<p>Có thể thấy rằng lớp <code>Student</code> đã được thừa hưởng những phương thức của lớp <code>Person</code>.</p>\n<h3><strong>3. Tính đa hình</strong></h3>\n<p>Tính đa hình trong code dưới 3 hình thức: nạp chồng phương thức, ghi đè phương thức và đa hình thông qua các đối tượng đa hình(polymorphic objects).</p>\n<p><strong>Ví dụ về tính đa hình với nạp chồng phương thức: </strong>Phương thức cộng sẽ có các \"forms\" là cộng 2 số nguyên, cộng 2 số thực, cộng 3 số nguyên, v.v.. Có thể thấy cùng là phương thức cộng nhưng lại có nhiểu kiểu khác nhau nên đây chính là biểu hiện của tính đa hình.</p>\n<pre class=\"language-javascript\"><code>package OOP;\n\nclass Calculator {\n   public int add(int a, int b) {\n      return a + b;\n   }\n\n   public double add(double a, double b) {\n      return a + b;\n   }\n\n   public int add(int a, int b, int c) {\n      return a + b + c;\n   }\n}\n\npublic class Entry {\n   public static void main(String[] args) {\n      Calculator s = new Calculator();\n      System.out.println(s.add(1, 2));\n      System.out.println(s.add(2.1, 2.4));\n      System.out.println(s.add(1, 2, 3));\n   }\n}</code></pre>\n<p>Kết quả khi chạy chương trình:</p>\n<pre class=\"language-markup\" tabindex=\"0\"><code>3\n4.5\n6</code></pre>\n<h3><strong>OOP trong Javascript</strong></h3>\n<p><strong>Javascript</strong> thì khác, không như Java, chúng ta cần phải áp dụng một vài thủ thuật để thực hiện các đặc tính này.</p>\n<h3>1. Tính đóng gói</h3>\n<p>Trong <strong>Javascript</strong>, để thực hiện tính bao đóng, ta có thể tạo ra 1 <em>Constructor Function</em>, đóng gói toàn bộ các trường và hàm vào 1 object. Thông thường, các bạn hay khai báo như sau:</p>\n<pre class=\"language-javascript\"><code>function Person(firstName, lastName) {\n  this.firstName = firstName;\n  this.lastName = lastName;\n  this.showName = function() {\n     console.log(this.firstName + ' ' + this.lastName);\n  };\n}\n\nvar psn1 = new Person('Khoa', 'Nguyen');\n\n// các property khai báo vào biến this có thể bị truy xuất từ bên ngoài\n// object không còn bao đóng nữa\npsn1.firstName = 'changed';\nconsole.log(ps1.firstName); // changed</code></pre>\n<p>Với các khai báo này, tính bao đóng không được đảm bảo. Các property có thể bị truy cập, thay đổi từ bên ngoài. Ở đây, ta phải <strong>sử dụng biến cục bộ</strong>.</p>\n<pre class=\"language-javascript\"><code>function Person(firstName, lastName) {\n  var fstName = firstName;\n  var lstName = lastName;\n  \n  this.setFirstName = function(firstName) { \n      fstName = firstName; \n  };\n\n  this.getFirstName = function() {\n      return fstName; \n  };\n  \n  this.setLastName = function(lastName) { \n      lstName = lastName; \n  };\n\n  this.getLastName = function() { \n      return lstName; \n  };\n}\n\nvar person1 = new Person('Khoa', 'Nguyen');\nconsole.log(person1.fstName); // Undefined, không thể truy cập được\n\n\nconsole.log(person1.getFirstName()); // Khoa</code></pre>\n<p>Các <strong>biến cục bộ</strong> này chỉ có thể truy xuất trong <em>Constructor Function</em>, nó tương đương với các trường <code>private</code> trong Java.</p>\n<p>Trong <strong>javascript</strong>, không có cách nào để tạo ra các trường <code>protected</code> (Chỉ có thể truy cập từ class kế thừa) như <strong>Java</strong> và <strong>C#</strong> được.</p>\n<h3>2. Tính kế thừa</h3>\n<p>Trong <strong>Javascript</strong> không có từ khóa extends cũng như class, vậy nên <em>Prototype</em> (and <em>Prototype chains</em>) là sự triển khai tính kế thừa đối tượng của <strong>Javascript</strong>.</p>\n<p><strong>Ví dụ:</strong> </p>\n<pre class=\"language-javascript\"><code>function Person() {\n  this.firstName = 'Per';\n  this.lastName = 'son';\n  this.sayName = function() { return this.firstName + ' ' + this.lastName };\n}\n\n// Viết một Constructor Function khác\nfunction SuperMan(firstName, lastName) {\n  this.firstName = firstName;\n  this.lastName = lastName;\n}\n\n// Ta muốn SuperMan sẽ kế thừa các thuộc tính của Person\n// Sử dụng prototype để kế thừa\nSuperMan.prototype = new Person();\n\n// Tạo một object mới bằng Constructor Function \nvar sm = new SuperMan('Khoa', 'Nguyen');\nsm.sayName(); // Khoa Nguyen. Hàm này kế thừa từ prototype của Person</code></pre>\n<p>Khi trình thông dịch JS kiểm tra thuộc tính đối tượng định nghĩa cho nó, trước tiên nó kiểm kiểm tra object trước. Nếu object không có thuộc tính được định nghĩa, nó sẽ kiểm tra <em>prototype</em> của đối tượng với cùng thuộc tính, nếu nó được tìm thấy, nó sẽ trả về thuộc tính đó. Nó khác với OOP trong Java là prototype object có thể truy cập vào đối tượng tạo ra trước vào sau bất kể khi nào có sự thay đổi nào trên prototype</p>\n<pre class=\"language-javascript\" tabindex=\"0\"><code>function Bread() {}; // constructor function\nlet brownBread = new Bread(); // object of type \"Bread\"\nlet sodaBread = new Bread(); // object of type \"Bread\"\nBread.prototype.toast = function() {\n        console.log('I am toasting!');\n    }; // set the function on a toast property on the prototype\n// inherited prototype is accessible!\nbrownBread.toast(); // I am toasting!\nsodaBread.toast(); // I am toasting!</code></pre>\n<h3>3. Tính đa hình và trừu tượng</h3>\n<p>Đối với tính đa hình và tính trừu tượng, việc áp dụng 2 tính chất này trong Javascript là không rõ ràng. Do đó mình sẽ không trình bày trong bài viết này</p>\n<p>Việc áp dụng lập trình hướng đối tượng vào JavaScript là tương đối khó. Tuy nhiên, nếu bạn nắm vững những kiến thức cơ bản mà mình đã trình bày trên đây, thì mình tin chắc rằng bạn sẽ dễ dàng tìm hiểu thêm và áp dụng lập trình hướng đối tượng trong JavaScript.</p>\n<h3>Tạm kết</h3>\n<p>Như vậy trong bài viết này, chúng ta đã cùng tìm hiểu về <strong>OOP</strong> trong <strong>javascript</strong>. Bạn thấy thế nào về JS, hãy đưa ra những ý kiến trong quá trình sử dụng js nhé.</p>",
            "image": "https://tinpham231.github.io/gh-pages/media/posts/11/oop-trong-javascript-63734807042.6106.jpg",
            "author": {
                "name": "Pham Ba Tin"
            },
            "tags": [
                   "JavaScript"
            ],
            "date_published": "2024-12-31T00:31:39+07:00",
            "date_modified": "2024-12-31T00:31:39+07:00"
        },
        {
            "id": "https://tinpham231.github.io/gh-pages/asyncawait-trong-javascript-co-lam-kho-duoc-ban.html",
            "url": "https://tinpham231.github.io/gh-pages/asyncawait-trong-javascript-co-lam-kho-duoc-ban.html",
            "title": "Async/Await Trong Javascript Có Làm Khó Được Bạn?",
            "summary": "Mọi ngôn ngữ lập trình đều không hoàn hảo, nó sẽ luôn có những ưu và nhược điểm riêng. Javascript - một trong những ngôn ngữ lập trình phổ biến nhất hiện nay, đã phải trải qua một khoảng thời gian dài khó khăn khi phải&hellip;",
            "content_html": "<p><strong>Mọi ngôn ngữ lập trình đều không hoàn hảo, nó sẽ luôn có những ưu và nhược điểm riêng. Javascript - một trong những ngôn ngữ lập trình phổ biến nhất hiện nay, đã phải trải qua một khoảng thời gian dài khó khăn khi phải dựa vào callbacks để lập trình các đoạn code bất đồng bộ. Sau đó trong bản cập nhật ES7, JavaScript đã đưa ra một giải pháp mới được cộng đồng lập trình rất ủng hộ để giải quyết cái bài toàn bất đồng bộ chính là Async/Await.</strong></p>\n<h3><strong>Async/Await là gì?</strong></h3>\n<p>Trước đây, để làm việc với code bất đồng bộ, chúng ta sử dụng <strong>callback</strong> và <strong>promise</strong>, <strong>Async/Await</strong> là một cách mới để viết code bất đồng bộ, được <strong>Javascript</strong> giới thiệu từ bản cập nhật <strong>ES7</strong>. Nó được xây dựng trên <strong>Promise</strong> và tương thích với tất cả <strong>Promise</strong> dựa trên API. Trong đó:</p>\n<p><strong>Async</strong> được dùng để khai báo một hàm bất đồng bộ. Các hàm bất đồng bộ sẽ luôn trả về một giá trị. Việc sử dụng <strong>async</strong> chỉ đơn giản là ngụ ý rằng một lời hứa sẽ được trả lại và nếu một lời hứa không được trả lại, <strong>JavaScript</strong> sẽ tự động kết thúc nó.</p>\n<p><span class=\"JLqJ4b ChMk0b\" data-phrase-index=\"5\" data-language-to-translate-into=\"en\" data-language-for-alternatives=\"vi\"><strong>Await</strong> được sử dụng để chờ một Promise.</span> <span class=\"JLqJ4b ChMk0b\" data-phrase-index=\"6\" data-language-to-translate-into=\"en\" data-language-for-alternatives=\"vi\">Nó chỉ có thể được sử dụng bên trong một khối Async.</span> <span class=\"JLqJ4b ChMk0b\" data-phrase-index=\"7\" data-language-to-translate-into=\"en\" data-language-for-alternatives=\"vi\">Từ khóa <strong>Await</strong> làm cho <strong>JavaScript</strong> đợi cho đến khi promise trả về kết quả.</span> <span class=\"JLqJ4b ChMk0b\" data-phrase-index=\"8\" data-language-to-translate-into=\"en\" data-language-for-alternatives=\"vi\">Cần lưu ý rằng nó chỉ làm cho khối chức năng không đồng bộ chờ đợi chứ không phải toàn bộ chương trình thực thi.</span></p>\n<h3><strong>Cú pháp Async/Await</strong></h3>\n<h4><strong>1. Async</strong></h4>\n<p>Từ khóa <code>Async</code> được đặt trước 1 hàm làm cho hàm trả về promise.</p>\n<p><strong>Ví dụ:</strong></p>\n<pre class=\"language-javascript\"><code>async function myFunction() {\n  return \"Hello\";\n}</code></pre>\n<p>Tương tự như trên:</p>\n<pre class=\"language-javascript\"><code>async function myFunction() {\n  return Promise.resolve(\"Hello\");\n}</code></pre>\n<p>Dưới đây là cách sử dụng Promise:</p>\n<pre class=\"language-javascript\"><code>myFunction().then(\n  function(value) { /* code if successful */ },\n  function(error) { /* code if some error */ }\n);</code></pre>\n<h4><strong>2. Await</strong></h4>\n<p>Từ khóa <code>Await</code> được đặt trước 1 hàm làm cho hàm chờ một promise.</p>\n<pre class=\"language-javascript\"><code>let value = await promise;</code></pre>\n<p>Từ khóa <code>await</code> chỉ có thể được sử dụng bên trong một hàm không đồng bộ.</p>\n<p><strong>Ví dụ:</strong></p>\n<pre class=\"language-javascript\"><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;body&gt;\n\n&lt;h2&gt;JavaScript async / await&lt;/h2&gt;\n\n&lt;h1 id=\"demo\"&gt;&lt;/h1&gt;\n\n&lt;script&gt;\nasync function myDisplay() {\n  let myPromise = new Promise(function(myResolve, myReject) {\n    myResolve(\"I love You !!\");\n  });\n  document.getElementById(\"demo\").innerHTML = await myPromise;\n}\n\nmyDisplay();\n&lt;/script&gt;\n\n&lt;/body&gt;\n&lt;/html&gt;</code></pre>\n<p><strong>Output:</strong></p>\n<p><img loading=\"lazy\" src=\"https://s3-sgn09.fptcloud.com/codelearnstorage/Media/Default/Users/Khoaa/Image/Capture.PNG\" data-is-external-image=\"true\"></p>\n<h3><strong>Những điều cần lưu ý khi sử dụng Async/Await</strong></h3>\n<h4><strong>1. Chúng ta không thể sử dụng Await bên trong các hàm thông thường</strong></h4>\n<p><strong>Ví dụ:</strong></p>\n<pre class=\"language-javascript\"><code>function firstAsync() {\n  let promise = Promise.resolve(10);\n  let result = await promise; // Syntax error\n}</code></pre>\n<p>Để hàm trên hoạt động bình thường, chúng ta cần thêm từ khóa <code>async</code> trước function firstAsync();</p>\n<h4>2. Async/Await thực hiện tuần tự</h4>\n<p>Đây không hẳn là điều xấu, nhưng thực hiện song song sẽ nhanh hơn nhiều.</p>\n<p><strong>Ví dụ:</strong></p>\n<pre class=\"language-javascript\"><code>async function sequence() {\n  await promise1(50); // Wait 50ms…\n  await promise2(50); // …then wait another 50ms.\n  return \"done!\";\n}</code></pre>\n<p>Đoạn code trên mất 100ms để hoàn thành, không phải một lượng thời gian lớn nhưng vẫn chậm. <span class=\"JLqJ4b ChMk0b\" data-phrase-index=\"2\" data-language-to-translate-into=\"en\" data-language-for-alternatives=\"vi\">Điều này xảy ra là do nó đang diễn ra theo trình tự.</span> <span class=\"JLqJ4b ChMk0b\" data-phrase-index=\"3\" data-language-to-translate-into=\"en\" data-language-for-alternatives=\"vi\">Hai hàm được trả lại, cả hai đều mất 50ms để hoàn thành.</span> <span class=\"JLqJ4b ChMk0b\" data-phrase-index=\"4\" data-language-to-translate-into=\"en\" data-language-for-alternatives=\"vi\">Hàm thứ hai chỉ thực hiện sau khi hàm đầu tiên được giải quyết.</span> <span class=\"JLqJ4b ChMk0b\" data-phrase-index=\"5\" data-language-to-translate-into=\"en\" data-language-for-alternatives=\"vi\">Đây không phải là một thực tiễn tốt, vì các yêu cầu lớn có thể rất tốn thời gian.</span> <span class=\"JLqJ4b ChMk0b\" data-phrase-index=\"6\" data-language-to-translate-into=\"en\" data-language-for-alternatives=\"vi\">Chúng ta phải thực hiện song song.</span></p>\n<p><span class=\"JLqJ4b ChMk0b\" data-phrase-index=\"6\" data-language-to-translate-into=\"en\" data-language-for-alternatives=\"vi\">Chúng ta có thể làm được điều đó bằng cách sử dụng <code>Promise.all()</code></span></p>\n<p><span class=\"JLqJ4b ChMk0b\" data-phrase-index=\"6\" data-language-to-translate-into=\"en\" data-language-for-alternatives=\"vi\"><strong>Theo MDN:</strong> <em>\"Phương thức <code><strong>Promise.all(iterable)</strong></code> trả ra một Promise mới và promise mới này chỉ được kết thúc khi tất cả các promise trong <code><strong>iterable </strong></code>kết thúc hoặc có một promise nào đó xử lý thất bại. Kết quả của promise mới này là một mảng chứa kết quả của tất cả các promise theo đúng thứ tự hoặc kết quả lỗi của promise gây lỗi.\"</em></span></p>\n<p><strong><span class=\"JLqJ4b ChMk0b\" data-phrase-index=\"6\" data-language-to-translate-into=\"en\" data-language-for-alternatives=\"vi\">Ví dụ:</span></strong></p>\n<pre class=\"language-javascript\"><code>async function sequence() {\n    await Promise.all([promise1(), promise2()]);  \n    return \"done!\";\n}</code></pre>\n<p>Hàm <code>Promise.all()</code> giải quyết khi tất cả các lời hứa bên trong có thể lặp được giải quyết và sau đó trả về kết quả.</p>\n<h3><strong>Xử lí lỗi với Async/Await</strong></h3>\n<p>Kết quả bình thường khi bạn sử dụng async/await là một kết quả đã được resolve. Nhưng khi promise bị reject và exception xảy ra thì phải làm gì? Chúng ta có thể dùng<strong> try…catch</strong> để giải quyết các lỗi này như các hàm bình thường khác.</p>\n<p><strong>Ví dụ:</strong></p>\n<p>Nếu một promise giải quyết bình thường, sau đó <code>await promise</code>trả về kết quả. Nhưng trong trường hợp từ chối, nó sẽ ném lỗi, giống như có một câu lệnh <code>throw</code> tại dòng đó.</p>\n<pre class=\"language-javascript\"><code>async function f() {\n  await Promise.reject(new Error(\"Whoops!\"));\n}</code></pre>\n<p>Trong tình huống thực tế, lời hứa có thể mất một thời gian trước khi nó từ chối. Trong trường hợp đó sẽ có độ trễ trước khi <code>await </code>đưa ra lỗi.</p>\n<p>Chúng ta có thể bắt lỗi đó bằng cách sử dụng <code>try..catch</code>, giống như cách thông thường <code>throw</code>:</p>\n<pre class=\"language-javascript\"><code>async function f() {\n\n  try {\n    let response = await fetch('http://no-such-url');\n  } catch(err) {\n    alert(err); // TypeError: failed to fetch\n  }\n}\n\nf();</code></pre>\n<h3><strong>Tại sao nên dùng Async/Await?</strong></h3>\n<h4><strong>1. Ngắn gọn và sạch sẽ</strong></h4>\n<p>Ưu điểm đơn giản nhất chính là số lượng code ta cần viết đã giảm đi đáng kể. Không cần phải <em>then</em> rồi <em>catch</em> gì cả, chỉ viết như code chạy tuần tự, sau đó <strong>dùng try/catch thông thường</strong> để bắt lỗi.</p>\n<h4>2. Xử lí lỗi</h4>\n<p><strong>Async/await</strong> giúp ta xử lý cả error đồng bộ lẫn error bất đồng bộ theo cùng 1 cấu trúc. Tạm biệt <code class=\"markup--code markup--p-code prettyprinted\"><span class=\"kwd\">try</span><span class=\"pun\">/</span><span class=\"kwd\">catch</span></code>. Với đoạn code dưới dùng promise, <code class=\"markup--code markup--p-code prettyprinted\"><span class=\"kwd\">try</span><span class=\"pun\">/</span><span class=\"kwd\">catch</span></code> sẽ không bắt được lỗi nếu <code class=\"markup--code markup--p-code prettyprinted\"><span class=\"pln\">JSON</span><span class=\"pun\">.</span><span class=\"pln\">parse</span></code>lỗi do nó xảy ra bên trong promise. Ta cần gọi  <code class=\"markup--code markup--p-code prettyprinted\"><span class=\"pun\">.</span><span class=\"kwd\">catch</span></code> bên trong promise và lặp lại code xử lý error, điều mà chắc chắn sẽ trở nên rắc rối hơn cả <code class=\"markup--code markup--p-code prettyprinted\"><span class=\"pln\">console</span><span class=\"pun\">.</span><span class=\"pln\">log</span></code>trong đoạn code production.</p>\n<pre class=\"language-javascript\"><code>const makeRequest = () =&gt; {\n  try {\n    getJSON()\n      .then(result =&gt; {\n        // this parse may fail\n        const data = JSON.parse(result)\n        console.log(data)\n      })\n      // uncomment this block to handle asynchronous errors\n      // .catch((err) =&gt; {\n      //   console.log(err)\n      // })\n  } catch (err) {\n    console.log(err)\n  }</code></pre>\n<p>Bây giờ hãy nhìn vào đoạn code sử dụng async/await. Khối <code class=\"markup--code markup--p-code prettyprinted\"><span class=\"kwd\">catch</span></code>giờ sẽ xử lý các lỗi parsing.</p>\n<pre class=\"language-javascript\"><code>const makeRequest = async () =&gt; {\n  try {\n    // this parse may fail\n    const data = JSON.parse(await getJSON())\n    console.log(data)\n  } catch (err) {\n    console.log(err)\n  }\n}</code></pre>\n<h4>3. Câu lệnh điều kiện</h4>\n<p>Hãy tưởng tượng một cái gì đó giống như đoạn mã bên dưới tìm nạp một số dữ liệu và quyết định xem nó có nên trả lại dữ liệu đó hay không hoặc lấy thêm chi tiết dựa trên một số giá trị trong dữ liệu.</p>\n<pre class=\"language-javascript\"><code>const makeRequest = () =&gt; {\n  return getJSON()\n    .then(data =&gt; {\n      if (data.needsAnotherRequest) {\n        return makeAnotherRequest(data)\n          .then(moreData =&gt; {\n            console.log(moreData)\n            return moreData\n          })\n      } else {\n        console.log(data)\n        return data\n      }\n    })\n}</code></pre>\n<p>Chỉ nhìn vào đoạn code trên thôi cũng đã khiến bạn đau đầu. Thật dễ dàng bị lạc trong tất cả các câu lệnh lồng nhau (6 cấp độ), dấu ngoặc nhọn và trả về chỉ cần thiết để truyền tải kết quả cuối cùng cho đến hàm chính.</p>\n<p>Khi sử dụng async/await, ta sẽ có đoạn code mới dễ đọc hơn.</p>\n<pre class=\"language-javascript\"><code>const makeRequest = async () =&gt; {\n  const data = await getJSON()\n  if (data.needsAnotherRequest) {\n    const moreData = await makeAnotherRequest(data);\n    console.log(moreData)\n    return moreData\n  } else {\n    console.log(data)\n    return data    \n  }\n}</code></pre>\n<p>Với promise hoặc callback, việc kết hợp if/else hoặc retry với code asynchnous là một cực hình vì ta phải viết code lòng vòng, rắc rối. Với async/await, việc này vô cùng dễ dàng.</p>\n<h4>4. Debug</h4>\n<p>Cuối cùng khi bạn làm việc với async/await, việc debug trở nên rất đơn giản. Với async / await, bạn không cần nhiều các arrow function và bạn có thể thực hiện các cuộc gọi chờ chính xác như thể chúng là các cuộc gọi đồng bộ thông thường.</p>\n<p>Mỗi lần dùng await được tính là một dòng code, do đó ta có thể đặt debugger để debug từng dòng như thường.</p>\n<h3><strong>Tạm kết</strong></h3>\n<p>Như vậy, trong bài viết này chúng ta đã cũng tìm hiểu những vấn đề cơ bản về Async/Await trong Javascript. Nếu các bạn thấy bài viết hữu ích hãy rate 5* và share cho mọi người tham khảo!</p>\n<p>Hãy để lại comment để mình có thể hoàn thiện bản thân hơn trong tương lai. Cám ơn các bạn!</p>\n<p>Nguồn tham khảo:</p>\n<ul>\n<li><a href=\"https://www.w3schools.com/js/js_async.asp\" target=\"_blank\" rel=\"noopener\">W3SCHOOL</a></li>\n<li>\n<p><a href=\"https://hackernoon.com/6-reasons-why-javascripts-async-await-blows-promises-away-tutorial-c7ec10518dd9\" target=\"_blank\" rel=\"noopener\">6 Reasons Why JavaScript Async/Await Blows Promises Away</a></p>\n</li>\n</ul>",
            "image": "https://tinpham231.github.io/gh-pages/media/posts/10/asyncawait-trong-javascript-63741267332.9522.jpg",
            "author": {
                "name": "Pham Ba Tin"
            },
            "tags": [
                   "JavaScript"
            ],
            "date_published": "2024-12-31T00:25:02+07:00",
            "date_modified": "2024-12-31T00:25:02+07:00"
        },
        {
            "id": "https://tinpham231.github.io/gh-pages/7-tips-va-tricks-trong-javascript-giup-ban-chuyen-nghiep-hon.html",
            "url": "https://tinpham231.github.io/gh-pages/7-tips-va-tricks-trong-javascript-giup-ban-chuyen-nghiep-hon.html",
            "title": "7 Tips Và Tricks Trong Javascript Giúp Bạn Chuyên Nghiệp Hơn",
            "summary": "Những mẹo dưới đây có thể giúp bạn tối ưu code Javascript của mình, giúp cho những dòng code của bạn trở nên chuyên nghiệp hơn, gọn gàng hơn Kiểu đối tượng Set trong Javascript và toán tử spread ra mắt ở phiên bản ES6. Chúng ta có thể&hellip;",
            "content_html": "<p><strong>Những mẹo dưới đây có thể giúp bạn tối ưu code Javascript của mình, giúp cho những dòng code của bạn trở nên chuyên nghiệp hơn, gọn gàng hơn</strong></p>\n<h3>1. Lọc ra những giá trị xuất hiện một lần trong mảng.</h3>\n<p>Kiểu đối tượng <code>Set</code> trong Javascript và toán tử <code>spread </code>ra mắt ở phiên bản ES6. Chúng ta có thể kết hợp 2 điều này để tạo ra một mảng mới từ mảng đã cho và các phần tử trong mảng chỉ xuất hiện một lần.</p>\n<pre class=\"language-javascript\"><code>const array = [1, 1, 2, 5, 3, 4, 4, 5]\nconst uniqueArray = [...new Set(array)]\n\nconsole.log(uniqueArray)\n// Results: [1, 2, 5, 3, 4]</code></pre>\n<h3>2. Every and some.</h3>\n<p><code>Every </code>function trả về giá trị boolean. Nếu tất cả phần tử trong mảng thỏa mãn điều kiện thì sẽ trả về <strong><code>true</code></strong>. Bên cạnh đó, <code>some </code>function chỉ kiểm trả nếu tồn tại ít nhất một phần tử trong mảng thỏa điều kiện thì trả về <strong>true</strong>.</p>\n<pre class=\"language-javascript\"><code>const firstArray = [12, 2, 3, 5, 6]\nconst secondArray = [20, -5, 3, 1, 6]\n\nconst isPositive = (number) =&gt; {\n  return number &gt; 0;\n}\n\nconsole.log(firstArray.every(isPositive));\n// true (vì tất cả phần tử trong mảng này đều thỏa điều kiện)\nconsole.log(secondArray.every(isPositive));\n// false (vì có một phần tử -5 không thỏa điều kiện)\n\nconsole.log(firstArray.some(isPositive));\n// true\nconsole.log(secondArray.some(isPositive))\n// true (tồn tại phần tử thỏa điều kiện)</code></pre>\n<h3>3. Chuyển từ số sang kiểu Boolean.</h3>\n<p>Khai báo một biến có giá trị <strong>boolean</strong>, ngoài cách khai báo thông thường (cho giá trị của biến là <strong>true</strong> hoặc<strong> false</strong>) thì có thể làm theo cách dưới đây.</p>\n<pre class=\"language-javascript\"><code>const isTrue = !0;\nconst isFalse = !1;\nconst alsoFalse = !!0;\n\nconsole.log(isTrue);\n// true\nconsole.log(isFalse);\n// false\nconsole.log(alsoFalse);\n// false</code></pre>\n<h3>4. Chuyển sang kiểu String.</h3>\n<p>Với những ngôn ngữ, ta có thể chuyển số sang string bằng hàm <code>toString()</code>. Javascript cũng vậy, tuy nhiên còn có cách khác nhanh gọn hơn để làm điều đó như ví dụ dưới đây.</p>\n<pre class=\"language-javascript\"><code>const value = 1 + \"\";\n\nconsole.log(value);\n// \"1\"</code></pre>\n<h3>5. Chuyển sang kiểu Number.</h3>\n<p>Việc chuyển từ String sang Number có thể sử dụng <code>parseInt()</code> trong Javascript. Nhưng có cách khác ngắn hơn để làm điều này đó chính ra sử dụng toán tử +.</p>\n<pre class=\"language-javascript\"><code>var value = \"15\"\nvalue = +value;\n\nconsole.log(value);\n// 15\nconsole.log(typeof value);\n// \"number\"</code></pre>\n<h3>6. Chuyển từ số thập phân sang số nguyên.</h3>\n<p>Nếu muốn chuyển từ một số thập phân sang số nguyên, bạn có thể sử dụng các function của Object Math như <code>Math.floor()</code>, <code>Math.ceil()</code> hoặc <code>Math.round()</code>. Nhưng cách nhanh nhất để làm điều này là sử dụng toán tử bitwise OR ( | ).</p>\n<pre class=\"language-javascript\"><code>console.log(5.9 | 0); // 5\nconsole.log(5.1 | 0); // 5</code></pre>\n<h3>7. Format code JSON.</h3>\n<p>Kiểu JSON nếu hiển thị trên một đường thẳng sẽ rất khó đọc, để dễ dàng đọc kiểu JSON hơn thì chúng ta có thể sử dụng method <code>stringify()</code> như ví dụ dưới đây.</p>\n<pre class=\"language-javascript\"><code>let obj = {name: 'Code learn', age: '3'}\n\nconsole.log(obj)\nconsole.log(JSON.stringify(obj, null, '\\t'))</code></pre>\n<p>Kết quả:</p>\n<p><img loading=\"lazy\" src=\"https://s3-sgn09.fptcloud.com/codelearnstorage/Media/Default/Users/nman_2Evn/node/Capture.PNG\" data-is-external-image=\"true\"></p>\n<p>Giữa dòng đầu và dòng thứ hai thì tất nhiên dòng đầu sẽ dễ đọc hơn đúng không nào ?</p>\n<h3>Tạm kết.</h3>\n<p>Trên đây là 7 mẹo và thủ thuật khi code Javascript khiến cho đoạn code của bạn sẽ <strong>dễ đọc hơn</strong> và <strong>không cần</strong> dùng những function, method dài dòng. Hy vọng chia sẻ của mình sẽ có ích cho những bạn đang học Javascript. Nếu có thắc mắc hay đóng góp các bạn có thể bình luận bên dưới. Cảm ơn các bạn rất nhiều, chúc các bạn học tốt.</p>",
            "image": "https://tinpham231.github.io/gh-pages/media/posts/9/7-meo-va-thu-thuat-trong-javascript-63748636771.74.jpg",
            "author": {
                "name": "Pham Ba Tin"
            },
            "tags": [
                   "JavaScript"
            ],
            "date_published": "2024-12-31T00:14:08+07:00",
            "date_modified": "2024-12-31T00:14:08+07:00"
        },
        {
            "id": "https://tinpham231.github.io/gh-pages/lam-quen-voi-dom-document-object-model-trong-javascript.html",
            "url": "https://tinpham231.github.io/gh-pages/lam-quen-voi-dom-document-object-model-trong-javascript.html",
            "title": "Môi trường Node Js, Browser và những điểm khác biệt",
            "summary": "Trước khi đi vào vấn đề chính thì chúng ta cần nắm rõ hai khái niệm sau đây: Node và Browser. Node là một môi trường máy chủ mã nguồn mở, được xây dựng trên bộ công cụ V8 Javascript - một bộ công cụ nổi tiếng&hellip;",
            "content_html": "<p class=\"align-left\">Trước khi đi vào vấn đề chính thì chúng ta cần nắm rõ hai khái niệm sau đây: <strong>Node</strong> và <strong>Browser.</strong></p>\n<h3 class=\"align-left\">Node là gì ?</h3>\n<p class=\"align-left\">Node là một môi trường máy chủ mã nguồn mở, được xây dựng trên bộ công cụ V8 Javascript - một bộ công cụ nổi tiếng của Google. Nền tảng Node runtime bao gồm mọi thứ mà bạn cần để hoàn thành một chương trình Javascript.</p>\n<h3 class=\"align-left\">Browser là gì ?</h3>\n<p class=\"align-left\">Browser hay còn gọi là trình duyệt web, bất cứ phần mềm nào cho phép bạn truy cập website, biên dịch được mã HTML, CSS, Javascript và cho phép lưu cookie thì được gọi là Browser.</p>\n<h3 class=\"align-left\">Sự khác biệt giữa hai môi trường Node và Browser</h3>\n<p class=\"align-left\">Điểm giống nhau: Cả hai đều là môi trường để thực thi code Javascript. nhưng node</p>\n<p>thực hiện việc đó ở phía máy chủ (server), còn trình duyệt thực hiện ở phía client. Và cả hai đều cùng sử dụng Javascript engine.</p>\n<p class=\"align-left\">Điểm khác nhau: </p>\n<ul>\n<li class=\"align-left\">Ở <strong>Browser</strong>, bạn có thể tương tác với DOM hoặc các API (localStorage, sessionStorage,..). Tuy nhiên những thứ đó không tồn tại ở <strong>Node</strong>. Bên cạnh đó <strong>Node</strong> cũng không có các object \"<strong>document</strong>\" và \"<strong>window</strong>\" và những đối tượng khác có sẵn trong <strong>Browser</strong>.</li>\n</ul>\n<pre class=\"language-javascript\"><code>var name = 'Code Learn'\n\nconsole.log(window.name);</code></pre>\n<p>Đoạn code trên nếu chạy ở <strong>Node</strong> sẽ báo lỗi <strong><em>window is not defiend</em></strong>.</p>\n<ul>\n<li><strong>Browser</strong> không có các API mà <strong>Node Js</strong> cung cấp trong npm (node package manager). </li>\n</ul>\n<p>      <img loading=\"lazy\" src=\"https://s3-sgn09.fptcloud.com/codelearnstorage/Media/Default/Users/nman_2Evn/node/2.png\" data-is-external-image=\"true\"></p>\n<ul>\n<li>Ở <strong>NodeJs,</strong> bạn có thể kiểm soát được môi trường khi phát triển, và bạn có thể chọn version cho NodeJs. Ở môi trường <strong>Browser</strong> thì bạn không có nhiều quyền lựa chọn để sử dụng.</li>\n<li>Với <strong>NodeJs</strong>, bạn có thể sử dụng từ khóa \"<strong>require</strong>\" để sử dụng các module nhưng ở <strong>Browser</strong> thì không. Khi bạn sử dụng \"<strong>require</strong>\" trong <strong>Browser</strong> thì trình duyệt sẽ báo lỗi.</li>\n</ul>\n<p><img loading=\"lazy\" src=\"https://s3-sgn09.fptcloud.com/codelearnstorage/Media/Default/Users/nman_2Evn/node/1.png\" data-is-external-image=\"true\"></p>\n<ul>\n<li><strong>Browser</strong> có giao diện đồ họa còn <strong>Node</strong> thì không.</li>\n<li><strong>Ở Node</strong>, bạn có toàn quyền truy cập hệ thống người dùng. Không giống <strong>Browser</strong>, <strong>NodeJs</strong> có thể truy cập hệ thống của bạn như các ứng dụng khác. Có nghĩa là bạn có thể đọc và ghi trực tiếp từ file system hoặc là thực thi những phần mềm khác. Bên cạnh đó bạn còn có thể viết một ứng dụng desktop hoàn toàn có thể với <strong>NodeJs</strong> bao gồm UI thông qua các modules (ví dụ <a href=\"https://www.electronjs.org/\" target=\"_blank\" rel=\"noopener\">Electron</a>). Vì có thể truy cập vào hệ thống người dùng nên cần tránh chạy các đoạn code Javascript không đáng tin cậy ở NodeJs.</li>\n</ul>\n<h3>Tạm kết</h3>\n<p>Trên đây là những sự khác biệt giữa Node và Browser mà bất kì ai cũng cần phải biết. Nhằm tránh những lỗi không mong muốn thì bạn cầm nắm rõ những vấn đề này. Hy vọng bài viết này giúp ích cho những bạn mới bắt đầu học lập trình. Nếu có góp ý hay thắc mắc gì thì vui lòng comment bên dưới giúp mình nhé. Chúc các bạn học tốt.</p>",
            "image": "https://tinpham231.github.io/gh-pages/media/posts/8/moi-truong-node-js-browser-va-khac-biet-63745001344.3067.jpg",
            "author": {
                "name": "Pham Ba Tin"
            },
            "tags": [
                   "JavaScript"
            ],
            "date_published": "2024-12-30T23:53:44+07:00",
            "date_modified": "2024-12-31T00:17:53+07:00"
        },
        {
            "id": "https://tinpham231.github.io/gh-pages/javascript-ngon-ngu-lap-trinh-vua-cua-web.html",
            "url": "https://tinpham231.github.io/gh-pages/javascript-ngon-ngu-lap-trinh-vua-cua-web.html",
            "title": "JavaScript: Ngôn Ngữ Lập Trình &quot;Vua&quot; của Web",
            "summary": "Khi nhắc đến lập trình web, JavaScript là cái tên không thể không nhắc đến. Đây không chỉ là một trong những ngôn ngữ lập trình phổ biến nhất hiện nay, mà còn là \"trái tim\" giúp các trang web trở nên sống động và&hellip;",
            "content_html": "<p>Khi nhắc đến lập trình web, <strong>JavaScript</strong> là cái tên không thể không nhắc đến. Đây không chỉ là một trong những ngôn ngữ lập trình phổ biến nhất hiện nay, mà còn là \"trái tim\" giúp các trang web trở nên sống động và tương tác. Trong bài viết này, chúng ta sẽ cùng tìm hiểu JavaScript là gì, lý do tại sao nó quan trọng và những điều thú vị xoay quanh ngôn ngữ này.</p>\n<h2><strong>JavaScript Là Gì?</strong></h2>\n<p>JavaScript là một ngôn ngữ lập trình <strong>đa năng</strong>, <strong>nhẹ</strong> và <strong>hướng đối tượng</strong>, được sử dụng chủ yếu để tạo các tính năng tương tác trên trang web. Ra mắt lần đầu tiên vào năm 1995 bởi Brendan Eich, JavaScript ban đầu được thiết kế để chạy trên trình duyệt web, nhưng ngày nay, nó đã vượt ra ngoài phạm vi đó và có thể được sử dụng trong các ứng dụng máy chủ, thiết bị di động, và thậm chí cả lập trình nhúng.</p>\n<h2><strong>Vai Trò Của JavaScript Trong Web</strong></h2>\n<p>JavaScript hoạt động song song với <strong>HTML</strong> và <strong>CSS</strong> – ba trụ cột chính của phát triển web. Mỗi ngôn ngữ có một vai trò riêng biệt:</p>\n<ul>\n<li><strong>HTML</strong>: Định nghĩa cấu trúc và nội dung của trang web.</li>\n<li><strong>CSS</strong>: Quyết định giao diện và phong cách của trang web.</li>\n<li><strong>JavaScript</strong>: Tạo ra các tính năng động, tương tác và logic cho trang web.</li>\n</ul>\n<p>Ví dụ, khi bạn nhấn vào một nút và thấy hộp thoại bật lên, hoặc khi kéo trang mà nội dung tự động tải thêm, đó chính là JavaScript đang hoạt động.</p>\n<h2><strong>Tại Sao JavaScript Lại Quan Trọng?</strong></h2>\n<h3>1. <strong>Phổ Biến và Toàn Diện</strong></h3>\n<p>JavaScript hiện là ngôn ngữ lập trình được sử dụng nhiều nhất trên thế giới. Theo khảo sát của Stack Overflow, JavaScript liên tục giữ vị trí đầu bảng trong nhiều năm liền.</p>\n<h3>2. <strong>Chạy Được Mọi Nơi</strong></h3>\n<p>Không giống như các ngôn ngữ lập trình khác, JavaScript có thể chạy trên <strong>mọi trình duyệt web</strong> mà không cần cài đặt thêm. Điều này khiến nó trở thành lựa chọn hàng đầu cho phát triển ứng dụng web.</p>\n<h3>3. <strong>Hỗ Trợ Đa Nền Tảng</strong></h3>\n<p>Nhờ sự phát triển của Node.js, JavaScript có thể được sử dụng để xây dựng cả ứng dụng máy chủ, ứng dụng di động, và thậm chí là ứng dụng máy tính để bàn.</p>\n<h2><strong>Những Điều Đặc Biệt Về JavaScript</strong></h2>\n<h3>1. <strong>Cộng Đồng Khổng Lồ</strong></h3>\n<p>JavaScript có một cộng đồng đông đảo và năng động. Các thư viện và framework phổ biến như <strong>React</strong>, <strong>Angular</strong>, và <strong>Vue.js</strong> đều được xây dựng trên nền tảng JavaScript, giúp lập trình viên phát triển ứng dụng nhanh chóng và hiệu quả.</p>\n<h3>2. <strong>Liên Tục Cải Tiến</strong></h3>\n<p>JavaScript không ngừng phát triển. Với các phiên bản mới như <strong>ES6+</strong>, ngôn ngữ này ngày càng trở nên mạnh mẽ và dễ sử dụng hơn.</p>\n<h3>3. <strong>Đa Dạng Ứng Dụng</strong></h3>\n<p>JavaScript không chỉ giới hạn ở trình duyệt. Nó được sử dụng để:</p>\n<ul>\n<li>Xây dựng ứng dụng web (frontend và backend).</li>\n<li>Phát triển ứng dụng di động (React Native).</li>\n<li>Tạo ứng dụng desktop (Electron).</li>\n<li>Lập trình game và ứng dụng IoT.</li>\n</ul>\n<h2><strong>Làm Thế Nào Để Bắt Đầu Với JavaScript?</strong></h2>\n<p>Nếu bạn muốn học JavaScript, hãy bắt đầu với những khái niệm cơ bản như:</p>\n<ul>\n<li>Cách khai báo biến (<code>var</code>, <code>let</code>, <code>const</code>).</li>\n<li>Vòng lặp (<code>for</code>, <code>while</code>).</li>\n<li>Hàm và cách sử dụng chúng.</li>\n</ul>\n<p>Sau đó, tiến đến các khái niệm nâng cao như <strong>lập trình hướng đối tượng (OOP)</strong>, <strong>bất đồng bộ (asynchronous programming)</strong>, và <strong>làm việc với API</strong>.</p>\n<h3>Tài nguyên học JavaScript:</h3>\n<ul>\n<li><a rel=\"noopener\" target=\"_new\" href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript\">MDN Web Docs</a>: Tài liệu chính thức và chi tiết nhất.</li>\n<li><a rel=\"noopener\" target=\"_new\" href=\"https://www.freecodecamp.org/\">freeCodeCamp</a>: Cung cấp khóa học miễn phí và bài tập thực hành.</li>\n<li><strong>Sách</strong>: <em>\"Eloquent JavaScript\"</em> của Marijn Haverbeke.</li>\n</ul>",
            "image": "https://tinpham231.github.io/gh-pages/media/posts/7/javascript-la-gi-co-vai-tro-gi-cach-bat-javascript-tren.001.jpg",
            "author": {
                "name": "Pham Ba Tin"
            },
            "tags": [
                   "JavaScript"
            ],
            "date_published": "2024-12-30T23:12:46+07:00",
            "date_modified": "2024-12-30T23:12:46+07:00"
        },
        {
            "id": "https://tinpham231.github.io/gh-pages/khai-niem-ve-bien-va-kieu-du-lieu-trong-java.html",
            "url": "https://tinpham231.github.io/gh-pages/khai-niem-ve-bien-va-kieu-du-lieu-trong-java.html",
            "title": "Khái niệm về Biến và Kiểu Dữ Liệu trong Java",
            "summary": "1. Biến là gì? Biến là một vùng nhớ được đặt tên trong bộ nhớ máy tính, dùng để lưu trữ dữ liệu mà chương trình có thể sử dụng và thay đổi trong quá trình chạy. kiểu_dữ_liệu tên_biến = giá_trị; Ví dụ: int age&hellip;",
            "content_html": "<h3>1. <strong>Biến là gì?</strong></h3>\n<p>Biến là một vùng nhớ được đặt tên trong bộ nhớ máy tính, dùng để lưu trữ dữ liệu mà chương trình có thể sử dụng và thay đổi trong quá trình chạy.</p>\n<h4>Cách khai báo biến trong Java:</h4>\n<pre class=\"language-java\"><code>kiểu_dữ_liệu tên_biến = giá_trị;\n</code></pre>\n<p>Ví dụ:</p>\n<pre class=\"language-java\"><code>int age = 25;\nString name = \"John\";\n</code></pre>\n<p>Trong đó:</p>\n<ul>\n<li><code>kiểu_dữ_liệu</code>: Xác định loại dữ liệu mà biến sẽ lưu trữ.</li>\n<li><code>tên_biến</code>: Tên dùng để tham chiếu đến dữ liệu.</li>\n<li><code>giá_trị</code>: Giá trị ban đầu được gán cho biến (có thể không cần gán ngay)</li>\n</ul>\n<h3>2. <strong>Các kiểu dữ liệu trong Java</strong></h3>\n<p>Java là một ngôn ngữ <strong>mạnh kiểu</strong> (strongly-typed), nghĩa là bạn phải xác định kiểu dữ liệu trước khi sử dụng biến. Có hai loại chính:</p>\n<h4><strong>a. Kiểu dữ liệu nguyên thủy (Primitive Types)</strong></h4>\n<p>Java cung cấp 8 kiểu dữ liệu nguyên thủy:</p>\n<table style=\"border-collapse: collapse; width: 136.895%; height: 542px;\" border=\"1\">\n<tbody>\n<tr>\n<td style=\"width: 14.0774%;\" width=\"84\">Kiểu dữ liệu</td>\n<td style=\"width: 11.8876%;\" width=\"105\">Kích thước</td>\n<td style=\"width: 21.1682%;\" width=\"138\">Giá trị tối thiểu</td>\n<td style=\"width: 37.3312%;\" width=\"138\">Giá trị tối đa</td>\n<td style=\"width: 15.6415%;\" width=\"279\">Ví dụ</td>\n</tr>\n<tr>\n<td style=\"width: 14.0774%;\" width=\"84\">byte</td>\n<td style=\"width: 11.8876%;\" width=\"105\">1 byte</td>\n<td style=\"width: 21.1682%;\" width=\"138\">-128</td>\n<td style=\"width: 37.3312%;\" width=\"138\">127</td>\n<td style=\"width: 15.6415%;\" width=\"279\">byte b = 10;</td>\n</tr>\n<tr>\n<td style=\"width: 14.0774%;\" width=\"84\">short</td>\n<td style=\"width: 11.8876%;\" width=\"105\">2 bytes</td>\n<td style=\"width: 21.1682%;\" width=\"138\">-32,768</td>\n<td style=\"width: 37.3312%;\" width=\"138\">32,767</td>\n<td style=\"width: 15.6415%;\" width=\"279\">short s = 200;</td>\n</tr>\n<tr>\n<td style=\"width: 14.0774%;\" width=\"84\">int</td>\n<td style=\"width: 11.8876%;\" width=\"105\">4 bytes</td>\n<td style=\"width: 21.1682%;\" width=\"138\">-2147483648</td>\n<td style=\"width: 37.3312%;\" width=\"138\">2^31-1</td>\n<td style=\"width: 15.6415%;\" width=\"279\">int i = 1000;</td>\n</tr>\n<tr>\n<td style=\"width: 14.0774%;\" width=\"84\">long</td>\n<td style=\"width: 11.8876%;\" width=\"105\">8 bytes</td>\n<td style=\"width: 21.1682%;\" width=\"138\">-9.22337E+18</td>\n<td style=\"width: 37.3312%;\" width=\"138\">2^63-1</td>\n<td style=\"width: 15.6415%;\" width=\"279\">long l = 5000L;</td>\n</tr>\n<tr>\n<td style=\"width: 14.0774%;\" width=\"84\">float</td>\n<td style=\"width: 11.8876%;\" width=\"105\">4 bytes</td>\n<td style=\"width: 21.1682%;\" width=\"138\">±1.4E-45</td>\n<td style=\"width: 37.3312%;\" width=\"138\">±3.4028235E38</td>\n<td style=\"width: 15.6415%;\" width=\"279\">float f = 3.14f;</td>\n</tr>\n<tr>\n<td style=\"width: 14.0774%;\" width=\"84\">double</td>\n<td style=\"width: 11.8876%;\" width=\"105\">8 bytes</td>\n<td style=\"width: 21.1682%;\" width=\"138\">±4.9E-324</td>\n<td style=\"width: 37.3312%;\" width=\"138\">±1.7976931348623157E308</td>\n<td style=\"width: 15.6415%;\" width=\"279\">double d = 3.14159;</td>\n</tr>\n<tr>\n<td style=\"width: 14.0774%;\" width=\"84\">char</td>\n<td style=\"width: 11.8876%;\" width=\"105\">2 bytes</td>\n<td style=\"width: 21.1682%;\" width=\"138\">'\\u0000' (0)</td>\n<td style=\"width: 37.3312%;\" width=\"138\">'\\uffff' (65,535)</td>\n<td style=\"width: 15.6415%;\" width=\"279\">char c = 'A';</td>\n</tr>\n<tr>\n<td style=\"width: 14.0774%;\" width=\"84\">boolean</td>\n<td style=\"width: 11.8876%;\" width=\"105\">1 bit</td>\n<td style=\"width: 21.1682%;\" width=\"138\">true hoặc false</td>\n<td style=\"width: 37.3312%;\" width=\"138\">N/A</td>\n<td style=\"width: 15.6415%;\" width=\"279\">boolean b = true;</td>\n</tr>\n</tbody>\n</table>\n<h4><strong>b. Kiểu dữ liệu tham chiếu (Reference Types)</strong></h4>\n<ul>\n<li><strong>String</strong>: Dùng để lưu trữ chuỗi ký tự. Ví dụ:</li>\n</ul>\n<pre class=\"language-java\"><code>String name = \"Hello, Java!\";\n</code></pre>\n<ul>\n<li><strong>Các đối tượng (Objects)</strong>: Được tạo từ các lớp (Classes). Ví dụ:</li>\n</ul>\n<pre class=\"language-java\"><code>Scanner input = new Scanner(System.in);\n</code></pre>\n<h3>3. <strong>Cách đặt tên biến</strong></h3>\n<p>Khi đặt tên biến trong Java, cần tuân theo các quy tắc sau:</p>\n<ul>\n<li>Tên biến phải bắt đầu bằng một ký tự (chữ cái), ký tự <code>_</code> hoặc <code>$</code>.</li>\n<li>Không được bắt đầu bằng số.</li>\n<li>Không được trùng với các từ khóa của Java (như <code>int</code>, <code>class</code>, <code>if</code>, ...).</li>\n<li>Sử dụng <strong>camelCase</strong> để tăng tính đọc dễ dàng. Ví dụ: <code>studentAge</code>, <code>totalAmount</code>.</li>\n</ul>\n<h3>4. <strong>Ví dụ minh họa</strong></h3>\n<p>Dưới đây là một ví dụ đơn giản về cách sử dụng biến và kiểu dữ liệu trong Java:</p>\n<pre class=\"language-java\"><code>public class Main {\n    public static void main(String[] args) {\n        int age = 20;                 // Kiểu int\n        double height = 1.75;         // Kiểu double\n        char grade = 'A';             // Kiểu char\n        boolean isStudent = true;     // Kiểu boolean\n        String name = \"Alice\";        // Kiểu String (tham chiếu)\n\n        System.out.println(\"Name: \" + name);\n        System.out.println(\"Age: \" + age);\n        System.out.println(\"Height: \" + height + \"m\");\n        System.out.println(\"Grade: \" + grade);\n        System.out.println(\"Is Student: \" + isStudent);\n    }\n}\n</code></pre>\n<p>Kết quả:</p>\n<pre class=\"language-vbnet\"><code>Name: Alice\nAge: 20\nHeight: 1.75m\nGrade: A\nIs Student: true\n</code></pre>\n<h3>5. <strong>Tại sao phải chọn đúng kiểu dữ liệu?</strong></h3>\n<ul>\n<li><strong>Tiết kiệm bộ nhớ</strong>: Ví dụ, nếu chỉ cần lưu số nhỏ (0-127), hãy chọn <code>byte</code> thay vì <code>int</code>.</li>\n<li><strong>Hiệu suất</strong>: Dữ liệu nhỏ sẽ được xử lý nhanh hơn.</li>\n<li><strong>Ngăn lỗi</strong>: Xác định đúng kiểu dữ liệu giúp tránh lỗi không tương thích khi xử lý dữ liệu.</li>\n</ul>\n<h3>Kết luận</h3>\n<p>Biến và kiểu dữ liệu là nền tảng quan trọng khi học Java. Khi hiểu rõ chúng, bạn sẽ dễ dàng viết được các chương trình chính xác và hiệu quả. Hãy bắt đầu thực hành với các ví dụ đơn giản và thử thay đổi kiểu dữ liệu để hiểu rõ hơn về cách chúng hoạt động!</p>\n<p> </p>",
            "image": "https://tinpham231.github.io/gh-pages/media/posts/6/data.jpg",
            "author": {
                "name": "Pham Ba Tin"
            },
            "tags": [
                   "Java"
            ],
            "date_published": "2024-12-30T22:32:37+07:00",
            "date_modified": "2024-12-30T23:05:11+07:00"
        },
        {
            "id": "https://tinpham231.github.io/gh-pages/cac-nguyen-ly-cua-lap-trinh-huong-doi-tuong-trong-java-phan-2.html",
            "url": "https://tinpham231.github.io/gh-pages/cac-nguyen-ly-cua-lap-trinh-huong-doi-tuong-trong-java-phan-2.html",
            "title": "Các Nguyên Lý của Lập Trình Hướng Đối Tượng trong Java  (Phần 2)",
            "summary": "Java và OOP: Hệ Sinh Thái Lập Trình Mạnh Mẽ Java là một ngôn ngữ lập trình hướng đối tượng, vì vậy tất cả các chương trình Java đều được tổ chức xung quanh các đối tượng và lớp. Trong bài blog này, chúng ta&hellip;",
            "content_html": "<p><strong>Java và OOP: Hệ Sinh Thái Lập Trình Mạnh Mẽ</strong></p>\n<p>Java là một ngôn ngữ lập trình hướng đối tượng, vì vậy tất cả các chương trình Java đều được tổ chức xung quanh các đối tượng và lớp. Trong bài blog này, chúng ta sẽ đi sâu vào cách áp dụng các nguyên lý OOP trong Java.</p>\n<h4>1. <strong>Encapsulation (Đóng Gói) trong Java</strong></h4>\n<p>Đóng gói là việc ẩn đi các chi tiết triển khai của đối tượng và chỉ cung cấp một giao diện công cộng cho các bên sử dụng. Điều này giúp bảo vệ dữ liệu khỏi việc bị truy cập hoặc thay đổi trực tiếp, đồng thời kiểm soát cách thức dữ liệu được truy xuất hoặc thay đổi.</p>\n<p>Ví dụ về đóng gói trong Java:</p>\n<div class=\"contain-inline-size rounded-md border-[0.5px] border-token-border-medium relative bg-token-sidebar-surface-primary dark:bg-gray-950\">\n<div class=\"flex items-center text-token-text-secondary px-4 py-2 text-xs font-sans justify-between rounded-t-md h-9 bg-token-sidebar-surface-primary dark:bg-token-main-surface-secondary select-none\">java</div>\n<div class=\"overflow-y-auto p-4\" dir=\"ltr\">\n<pre class=\"language-java\"><code>class Person {\n     private String name; \n     private int age; \n     // Getter và Setter \n     public String getName() { \n            return name; \n      }\n     public void setName(String name) { \n            this.name = name; \n     }\n     public int getAge() { \n            return age; \n     } \n     public void setAge(int age) {\n            this.age = age; \n     } \n}</code></pre>\n</div>\n</div>\n<p>Trong ví dụ trên, các thuộc tính <code>name</code> và <code>age</code> được đóng gói bằng cách khai báo là <code>private</code>, và chỉ có thể truy cập thông qua các phương thức getter và setter.</p>\n<h4>2. <strong>Inheritance (Kế Thừa) trong Java</strong></h4>\n<p>Kế thừa cho phép bạn tạo ra một lớp mới (subclass) dựa trên lớp hiện có (superclass). Lớp con có thể kế thừa các thuộc tính và phương thức của lớp cha, giúp giảm thiểu mã nguồn lặp lại.</p>\n<p>Ví dụ về kế thừa trong Java:</p>\n<div class=\"contain-inline-size rounded-md border-[0.5px] border-token-border-medium relative bg-token-sidebar-surface-primary dark:bg-gray-950\">\n<div class=\"flex items-center text-token-text-secondary px-4 py-2 text-xs font-sans justify-between rounded-t-md h-9 bg-token-sidebar-surface-primary dark:bg-token-main-surface-secondary select-none\">java</div>\n<div>\n<pre class=\"language-java\"><code>class Animal {\n    void sound() {\n        System.out.println(\"Some sound\");\n    }\n}\n\nclass Dog extends Animal {\n    @Override\n    void sound() {\n        System.out.println(\"Bark\");\n    }\n}</code></pre>\n</div>\n<div> </div>\n<div class=\"flex items-center text-token-text-secondary px-4 py-2 text-xs font-sans justify-between rounded-t-md h-9 bg-token-sidebar-surface-primary dark:bg-token-main-surface-secondary select-none\"><span style=\"color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);\">Trong ví dụ trên, lớp </span><code style=\"font-weight: var(--font-weight-normal);\">Dog</code><span style=\"color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);\"> kế thừa từ lớp </span><code style=\"font-weight: var(--font-weight-normal);\">Animal</code><span style=\"color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);\"> và ghi đè phương thức </span><code style=\"font-weight: var(--font-weight-normal);\">sound()</code><span style=\"color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);\"> để cung cấp hành vi cụ thể cho chó.</span></div>\n</div>\n<h4>3. <strong>Polymorphism (Đa Hình) trong Java</strong></h4>\n<p>Đa hình cho phép các đối tượng của các lớp khác nhau có thể gọi cùng một phương thức, nhưng thực hiện hành động khác nhau tùy vào lớp thực thể của đối tượng đó.</p>\n<p>Ví dụ về đa hình trong Java:</p>\n<div class=\"contain-inline-size rounded-md border-[0.5px] border-token-border-medium relative bg-token-sidebar-surface-primary dark:bg-gray-950\">\n<div class=\"flex items-center text-token-text-secondary px-4 py-2 text-xs font-sans justify-between rounded-t-md h-9 bg-token-sidebar-surface-primary dark:bg-token-main-surface-secondary select-none\">java</div>\n<div dir=\"ltr\">\n<pre class=\"language-java\"><code>class Animal {\n    void sound() {\n        System.out.println(\"Some sound\");\n    }\n}\n\nclass Dog extends Animal {\n    @Override\n    void sound() {\n        System.out.println(\"Bark\");\n    }\n}\n\nclass Cat extends Animal {\n    @Override\n    void sound() {\n        System.out.println(\"Meow\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Animal myAnimal = new Animal();\n        Animal myDog = new Dog();\n        Animal myCat = new Cat();\n        \n        myAnimal.sound();  // Output: Some sound\n        myDog.sound();     // Output: Bark\n        myCat.sound();     // Output: Meow\n    }\n}\n</code></pre>\n</div>\n</div>\n<p>Ở đây, các đối tượng của lớp <code>Dog</code> và <code>Cat</code> gọi phương thức <code>sound()</code>, nhưng mỗi đối tượng lại có cách thực hiện khác nhau.</p>\n<h4>4. <strong>Abstraction (Trừu Tượng) trong Java</strong></h4>\n<p>Trừu tượng cho phép bạn ẩn các chi tiết thực thi của một đối tượng và chỉ cung cấp các phương thức cần thiết. Trong Java, bạn có thể sử dụng lớp abstract hoặc interface để thực hiện trừu tượng.</p>\n<p>Ví dụ về trừu tượng trong Java:</p>\n<div class=\"contain-inline-size rounded-md border-[0.5px] border-token-border-medium relative bg-token-sidebar-surface-primary dark:bg-gray-950\">\n<div class=\"flex items-center text-token-text-secondary px-4 py-2 text-xs font-sans justify-between rounded-t-md h-9 bg-token-sidebar-surface-primary dark:bg-token-main-surface-secondary select-none\">java</div>\n<div dir=\"ltr\">\n<pre class=\"language-java\"><code>abstract class Animal {\n    abstract void sound();\n}\n\nclass Dog extends Animal {\n    void sound() {\n        System.out.println(\"Bark\");\n    }\n}\n</code></pre>\n</div>\n</div>\n<p>Lớp <code>Animal</code> là một lớp trừu tượng với phương thức <code>sound()</code> chưa được triển khai. Các lớp con như <code>Dog</code> sẽ triển khai phương thức này.</p>",
            "image": "https://tinpham231.github.io/gh-pages/media/posts/4/OOP.jpg",
            "author": {
                "name": "Pham Ba Tin"
            },
            "tags": [
                   "Java"
            ],
            "date_published": "2024-12-30T11:07:39+07:00",
            "date_modified": "2024-12-30T22:27:28+07:00"
        },
        {
            "id": "https://tinpham231.github.io/gh-pages/lap-trinh-huong-doi-tuong-la-gi-va-tai-sao-no-quan-trong.html",
            "url": "https://tinpham231.github.io/gh-pages/lap-trinh-huong-doi-tuong-la-gi-va-tai-sao-no-quan-trong.html",
            "title": "Lập Trình Hướng Đối Tượng là gì và Tại sao Nó Quan Trọng? (Phần 1)",
            "summary": "Giới Thiệu về Lập Trình Hướng Đối Tượng (OOP) Lập trình hướng đối tượng (OOP - Object-Oriented Programming) là một phương pháp lập trình sử dụng các đối tượng và lớp để tổ chức mã nguồn. OOP giúp xây dựng các ứng dụng có cấu&hellip;",
            "content_html": "<p><strong>Giới Thiệu về Lập Trình Hướng Đối Tượng (OOP)</strong></p>\n<p>Lập trình hướng đối tượng (OOP - Object-Oriented Programming) là một phương pháp lập trình sử dụng các đối tượng và lớp để tổ chức mã nguồn. OOP giúp xây dựng các ứng dụng có cấu trúc rõ ràng, dễ bảo trì và mở rộng. Các nguyên lý cơ bản của OOP bao gồm Encapsulation (Đóng gói), Inheritance (Kế thừa), Polymorphism (Đa hình) và Abstraction (Trừu tượng).</p>\n<p><strong>Tại sao OOP lại Quan Trọng?</strong></p>\n<ol>\n<li><strong>Tổ chức mã nguồn rõ ràng</strong>: OOP cho phép bạn chia mã thành các đối tượng độc lập, giúp dễ dàng quản lý và bảo trì mã nguồn.</li>\n<li><strong>Tái sử dụng mã nguồn</strong>: Thông qua kế thừa và đa hình, bạn có thể tái sử dụng các lớp và đối tượng, tiết kiệm thời gian và công sức khi phát triển phần mềm.</li>\n<li><strong>Dễ dàng mở rộng</strong>: OOP cho phép bạn mở rộng hệ thống bằng cách thêm các lớp mới mà không ảnh hưởng đến các lớp đã có.</li>\n<li><strong>Quản lý phức tạp</strong>: Với OOP, bạn có thể giải quyết các bài toán phức tạp bằng cách chia nhỏ vấn đề thành các phần dễ quản lý hơn.</li>\n</ol>\n<h3><strong>Các Nguyên Lý Cơ Bản của OOP</strong></h3>\n<ol>\n<li>\n<p><strong>Encapsulation (Đóng gói)</strong>: Đóng gói giúp bảo vệ dữ liệu và chỉ cho phép truy cập thông qua các phương thức. Bạn không thể thay đổi trực tiếp giá trị của thuộc tính mà phải thông qua getter và setter.</p>\n</li>\n<li>\n<p><strong>Inheritance (Kế thừa)</strong>: Inheritance cho phép một lớp (subclass) kế thừa các thuộc tính và phương thức từ một lớp khác (superclass). Điều này giúp bạn tạo ra các lớp con mà không phải viết lại mã đã có.</p>\n</li>\n<li>\n<p><strong>Polymorphism (Đa hình)</strong>: Polymorphism cho phép bạn gọi các phương thức từ các lớp khác nhau nhưng chúng có thể có cách hoạt động khác nhau. Điều này giúp tăng tính linh hoạt trong chương trình.</p>\n</li>\n<li>\n<p><strong>Abstraction (Trừu tượng)</strong>: Abstraction giúp ẩn đi các chi tiết triển khai không cần thiết và chỉ cung cấp các thông tin quan trọng cho người dùng hoặc hệ thống.</p>\n</li>\n</ol>\n<h3><strong>Kết Luận</strong></h3>\n<p>OOP là một trong những phương pháp lập trình mạnh mẽ và linh hoạt nhất. Việc nắm vững các nguyên lý của OOP sẽ giúp bạn phát triển các ứng dụng phức tạp và dễ bảo trì hơn. Hãy bắt đầu áp dụng OOP trong dự án của bạn để tận dụng tối đa những lợi ích mà nó mang lại!</p>",
            "image": "https://tinpham231.github.io/gh-pages/media/posts/3/OOP.jpg",
            "author": {
                "name": "Pham Ba Tin"
            },
            "tags": [
                   "Java"
            ],
            "date_published": "2024-12-30T11:01:49+07:00",
            "date_modified": "2024-12-30T11:23:42+07:00"
        },
        {
            "id": "https://tinpham231.github.io/gh-pages/kham-pha-cac-thu-vien-va-package-quan-trong-trong-java.html",
            "url": "https://tinpham231.github.io/gh-pages/kham-pha-cac-thu-vien-va-package-quan-trong-trong-java.html",
            "title": "Khám Phá Các Thư Viện và Package Quan Trọng trong Java",
            "summary": "Java là một trong những ngôn ngữ lập trình phổ biến nhất trên thế giới, được sử dụng rộng rãi trong phát triển phần mềm, ứng dụng di động, web, và nhiều lĩnh vực khác. Một trong những điểm mạnh của Java chính là hệ&hellip;",
            "content_html": "<p>Java là một trong những ngôn ngữ lập trình phổ biến nhất trên thế giới, được sử dụng rộng rãi trong phát triển phần mềm, ứng dụng di động, web, và nhiều lĩnh vực khác. Một trong những điểm mạnh của Java chính là hệ sinh thái thư viện phong phú, giúp lập trình viên dễ dàng tối ưu hóa công việc và phát triển ứng dụng hiệu quả. Trong bài viết này, chúng ta sẽ cùng khám phá các thư viện và package quan trọng trong Java, giúp bạn nâng cao kỹ năng lập trình.</p>\n<h3>1. <strong>Java Standard Library (Thư viện chuẩn của Java)</strong></h3>\n<p>Java cung cấp một bộ thư viện chuẩn vô cùng đa dạng và mạnh mẽ, giúp lập trình viên giải quyết nhiều vấn đề khác nhau. Đây là những thư viện tích hợp sẵn trong JDK (Java Development Kit) mà bạn có thể sử dụng mà không cần cài đặt thêm.</p>\n<h4>a. <strong>java.lang</strong></h4>\n<p>Đây là package quan trọng nhất trong Java, bao gồm các lớp cơ bản như <code>String</code>, <code>Math</code>, <code>Object</code>, và <code>System</code>. Các lớp trong <code>java.lang</code> luôn có sẵn và tự động được import trong mọi chương trình Java.</p>\n<ul>\n<li><strong>String</strong>: Cung cấp các phương thức để xử lý chuỗi văn bản.</li>\n<li><strong>Math</strong>: Bao gồm các hàm toán học cơ bản như <code>sqrt()</code>, <code>pow()</code>, <code>random()</code>.</li>\n<li><strong>Object</strong>: Lớp gốc cho tất cả các lớp khác trong Java.</li>\n<li><strong>System</strong>: Cung cấp các phương thức liên quan đến hệ thống như <code>exit()</code>, <code>currentTimeMillis()</code>.</li>\n</ul>\n<h4>b. <strong>java.util</strong></h4>\n<p>Package này cung cấp các lớp và giao diện phục vụ cho việc xử lý dữ liệu và collections. Một số thư viện nổi bật bao gồm:</p>\n<ul>\n<li><strong>ArrayList</strong>: Lớp danh sách động, giúp bạn quản lý các phần tử trong một mảng.</li>\n<li><strong>HashMap</strong>: Cung cấp cấu trúc dữ liệu bảng băm, giúp lưu trữ các cặp khóa-giá trị.</li>\n<li><strong>Date</strong>: Dùng để làm việc với thời gian và ngày tháng.</li>\n<li><strong>Collections</strong>: Chứa các phương thức tiện ích để làm việc với các collections.</li>\n</ul>\n<h4>c. <strong>java.io</strong></h4>\n<p>Package này cung cấp các lớp để xử lý input/output (I/O). Bạn có thể đọc và ghi dữ liệu từ tệp tin, nhập xuất dữ liệu qua mạng, và làm việc với các thiết bị ngoại vi.</p>\n<ul>\n<li><strong>File</strong>: Đối tượng để làm việc với các tệp và thư mục trong hệ thống file.</li>\n<li><strong>BufferedReader</strong>: Cung cấp khả năng đọc dữ liệu từ tệp tin một cách hiệu quả.</li>\n<li><strong>PrintWriter</strong>: Dùng để ghi dữ liệu vào tệp hoặc xuất ra console.</li>\n</ul>\n<h3>2. <strong>Các Thư Viện Bên Thứ Ba (Third-party Libraries)</strong></h3>\n<p>Ngoài các thư viện chuẩn, Java cũng hỗ trợ một loạt thư viện bên thứ ba được phát triển bởi cộng đồng hoặc các công ty phần mềm, giúp mở rộng khả năng của ngôn ngữ. Dưới đây là một số thư viện Java phổ biến.</p>\n<h4>a. <strong>Apache Commons</strong></h4>\n<p>Apache Commons là một bộ thư viện mạnh mẽ và phổ biến trong cộng đồng lập trình Java, cung cấp nhiều công cụ hữu ích cho lập trình viên.</p>\n<ul>\n<li><strong>Commons Lang</strong>: Cung cấp các tiện ích cho các lớp trong <code>java.lang</code>, như <code>StringUtils</code> để xử lý chuỗi văn bản, <code>ArrayUtils</code> để xử lý mảng.</li>\n<li><strong>Commons IO</strong>: Cung cấp các tiện ích để làm việc với file và I/O, giúp đơn giản hóa việc đọc và ghi dữ liệu.</li>\n</ul>\n<h4>b. <strong>Gson</strong></h4>\n<p>Gson là một thư viện được Google phát triển để chuyển đổi giữa các đối tượng Java và định dạng JSON (JavaScript Object Notation). Điều này cực kỳ hữu ích trong việc làm việc với API web hoặc các dữ liệu lưu trữ ở định dạng JSON.</p>\n<ul>\n<li><strong>JsonObject</strong>: Chuyển đổi dữ liệu từ và về định dạng JSON.</li>\n<li><strong>GsonBuilder</strong>: Dùng để tùy chỉnh cách Gson xử lý việc chuyển đổi dữ liệu.</li>\n</ul>\n<h4>c. <strong>JUnit</strong></h4>\n<p>JUnit là một thư viện kiểm thử đơn vị (unit testing) nổi tiếng trong Java. Thư viện này cung cấp các công cụ để kiểm tra các chức năng của chương trình một cách tự động và hiệu quả.</p>\n<ul>\n<li><strong>Assertions</strong>: Kiểm tra kết quả trả về của các phương thức.</li>\n<li><strong>Annotations</strong>: Các chú thích như <code>@Test</code>, <code>@Before</code>, <code>@After</code> để tổ chức các bài kiểm tra.</li>\n</ul>\n<h4>d. <strong>Spring Framework</strong></h4>\n<p>Spring là một framework nổi tiếng trong phát triển ứng dụng Java, giúp phát triển ứng dụng web, ứng dụng doanh nghiệp, và ứng dụng di động. Spring cung cấp các module như Spring MVC, Spring Boot, Spring Security, và nhiều tính năng khác hỗ trợ xây dựng ứng dụng nhanh chóng và hiệu quả.</p>\n<ul>\n<li><strong>Spring Boot</strong>: Giúp tạo ra các ứng dụng Java độc lập, với cấu hình tự động, giảm thiểu việc phải cấu hình phức tạp.</li>\n<li><strong>Spring Security</strong>: Cung cấp các công cụ bảo mật mạnh mẽ cho ứng dụng Java, bảo vệ khỏi các tấn công như SQL injection, XSS.</li>\n</ul>\n<h3>3. <strong>Các Công Cụ Quản Lý Dependency</strong></h3>\n<p>Quản lý các thư viện và package trong Java có thể trở nên khó khăn nếu không có công cụ hỗ trợ. Các công cụ như Maven và Gradle giúp tự động hóa quá trình tải về và quản lý các thư viện bên ngoài.</p>\n<h4>a. <strong>Maven</strong></h4>\n<p>Maven là một công cụ quản lý project và dependency, giúp lập trình viên dễ dàng cấu hình và tải các thư viện cần thiết cho dự án. Maven sử dụng một file <code>pom.xml</code> để khai báo các dependencies, plugins, và cấu hình dự án.</p>\n<h4>b. <strong>Gradle</strong></h4>\n<p>Gradle là một công cụ build hiện đại, mạnh mẽ hơn Maven trong một số trường hợp. Nó hỗ trợ các build script được viết bằng Groovy hoặc Kotlin, giúp tối ưu hóa quy trình xây dựng dự án.</p>\n<h3>4. <strong>Kết Luận</strong></h3>\n<p>Java cung cấp một hệ sinh thái thư viện rất phong phú, bao gồm cả thư viện chuẩn và các thư viện bên thứ ba. Việc hiểu và tận dụng các thư viện này sẽ giúp bạn tiết kiệm thời gian, cải thiện hiệu quả lập trình và giảm thiểu lỗi. Bằng cách sử dụng đúng các thư viện và package trong Java, bạn có thể phát triển ứng dụng nhanh chóng và dễ dàng hơn.</p>\n<p>Hãy tiếp tục khám phá và áp dụng các thư viện Java trong các dự án của bạn để nâng cao kỹ năng lập trình!</p>",
            "image": "https://tinpham231.github.io/gh-pages/media/posts/2/thuvien_package.jpg",
            "author": {
                "name": "Pham Ba Tin"
            },
            "tags": [
                   "Java"
            ],
            "date_published": "2024-12-30T10:47:15+07:00",
            "date_modified": "2024-12-30T11:00:50+07:00"
        },
        {
            "id": "https://tinpham231.github.io/gh-pages/java-vs-javascript.html",
            "url": "https://tinpham231.github.io/gh-pages/java-vs-javascript.html",
            "title": "Java vs JavaScript",
            "summary": " Cùng mình khám phá sự khác biệt giữa Java và JavaScript! Bạn đã từng bối rối vì cái tên gần giống nhau của hai ngôn ngữ này? Đừng lo! Bài viết này sẽ giúp bạn hiểu rõ lịch sử, sự khác biệt và ứng dụng&hellip;",
            "content_html": "<h2 data-pm-slice=\"1 1 []\"> Cùng mình khám phá sự khác biệt giữa Java và JavaScript!</h2>\n<p>Bạn đã từng bối rối vì cái tên gần giống nhau của hai ngôn ngữ này? Đừng lo! Bài viết này sẽ giúp bạn hiểu rõ lịch sử, sự khác biệt và ứng dụng thực tế của Java và JavaScript. Từ đó, bạn sẽ dễ dàng quyết định ngôn ngữ nào phù hợp với mục tiêu học tập hoặc dự án của mình.<br><br>Hãy bắt đầu hành trình khám phá ngay bây giờ!</p>\n<h2 data-pm-slice=\"1 1 []\">Java vs. JavaScript: Đâu là ngôn ngữ dành cho bạn?</h2>\n<p>Java và JavaScript là hai ngôn ngữ lập trình nổi bật, nhưng chúng hoàn toàn khác nhau về mục đích, cách sử dụng và đặc điểm kỹ thuật. Hãy cùng tìm hiểu lịch sử, sự khác biệt và ứng dụng của chúng để xem ngôn ngữ nào phù hợp với nhu cầu của bạn.</p>\n<h3>Lịch sử và Phát triển</h3>\n<h4>Java:</h4>\n<ul data-spread=\"false\">\n<li>\n<p><strong>Năm ra đời</strong>: 1995, được phát triển bởi Sun Microsystems (sau này thuộc Oracle).</p>\n</li>\n<li>\n<p><strong>Mục đích</strong>: Tạo ra các ứng dụng độc lập, đa nền tảng, từ desktop đến server.</p>\n</li>\n<li>\n<p><strong>Triết lý</strong>: \"Viết một lần, chạy mọi nơi\" (Write Once, Run Anywhere).</p>\n</li>\n<li>\n<p><strong>Phạm vi sử dụng</strong>: Ứng dụng doanh nghiệp, backend, di động (Android).</p>\n</li>\n</ul>\n<h4>JavaScript:</h4>\n<ul data-spread=\"false\">\n<li>\n<p><strong>Năm ra đời</strong>: 1995, do Brendan Eich phát triển tại Netscape.</p>\n</li>\n<li>\n<p><strong>Ban đầu</strong>: Gọi là \"LiveScript\", sau đó đổi tên thành JavaScript để tận dụng độ phổ biến của Java.</p>\n</li>\n<li>\n<p><strong>Mục đích</strong>: Thêm tính tương tác cho các trang web.</p>\n</li>\n<li>\n<p><strong>Phạm vi sử dụng</strong>: Web frontend, backend (Node.js), ứng dụng cross-platform.</p>\n</li>\n</ul>\n<h3 data-pm-slice=\"1 1 []\">Sự khác biệt giữa Java và JavaScript</h3>\n<table style=\"border-collapse: collapse; width: 138.462%;\" border=\"1\">\n<tbody>\n<tr>\n<th style=\"width: 22.0413%;\"><strong>Đặc điểm</strong></th>\n<th style=\"width: 37.025%;\"><strong>Java</strong></th>\n<th style=\"width: 41.0423%;\"><strong>JavaScript</strong></th>\n</tr>\n<tr>\n<td style=\"width: 22.0413%;\"><strong>Loại ngôn ngữ</strong></td>\n<td style=\"width: 37.025%;\">Ngôn ngữ lập trình đa năng</td>\n<td style=\"width: 41.0423%;\">Ngôn ngữ kịch bản, hướng đối tượng</td>\n</tr>\n<tr>\n<td style=\"width: 22.0413%;\"><strong>Cách biên dịch</strong></td>\n<td style=\"width: 37.025%;\">Biên dịch (compiled)</td>\n<td style=\"width: 41.0423%;\">Thông dịch (interpreted)</td>\n</tr>\n<tr>\n<td style=\"width: 22.0413%;\"><strong>Mục đích</strong></td>\n<td style=\"width: 37.025%;\">Ứng dụng backend, di động</td>\n<td style=\"width: 41.0423%;\">Tương tác web, frontend</td>\n</tr>\n<tr>\n<td style=\"width: 22.0413%;\"><strong>Chạy ở đâu?</strong></td>\n<td style=\"width: 37.025%;\">JVM (Java Virtual Machine)</td>\n<td style=\"width: 41.0423%;\">Trình duyệt hoặc Node.js</td>\n</tr>\n<tr>\n<td style=\"width: 22.0413%;\"><strong>Cú pháp</strong></td>\n<td style=\"width: 37.025%;\">Cấu trúc chặt chẽ, khai báo biến rõ ràng</td>\n<td style=\"width: 41.0423%;\">Linh hoạt, không bắt buộc khai báo kiểu biến</td>\n</tr>\n<tr>\n<td style=\"width: 22.0413%;\"><strong>Đối tượng sử dụng</strong></td>\n<td style=\"width: 37.025%;\">Lập trình viên backend, fullstack</td>\n<td style=\"width: 41.0423%;\">Lập trình viên frontend, fullstack</td>\n</tr>\n</tbody>\n</table>\n<h3 data-pm-slice=\"1 5 []\">Ứng dụng của Java và JavaScript</h3>\n<h4>Java:</h4>\n<ul data-spread=\"false\">\n<li>\n<p><strong>Ứng dụng doanh nghiệp</strong>: Hệ thống ngân hàng, phần mềm quản lý doanh nghiệp (ERP).</p>\n</li>\n<li>\n<p><strong>Ứng dụng di động</strong>: Phát triển ứng dụng Android.</p>\n</li>\n<li>\n<p><strong>Hệ thống backend</strong>: Xây dựng server, xử lý giao dịch lớn.</p>\n</li>\n<li>\n<p><strong>IoT (Internet of Things)</strong>: Các thiết bị thông minh và nhúng.</p>\n</li>\n</ul>\n<h4>JavaScript:</h4>\n<ul data-spread=\"false\">\n<li>\n<p><strong>Web frontend</strong>: Xây dựng giao diện người dùng tương tác, kết hợp HTML và CSS.</p>\n</li>\n<li>\n<p><strong>Web backend</strong>: Xây dựng server với Node.js.</p>\n</li>\n<li>\n<p><strong>Ứng dụng di động</strong>: Phát triển ứng dụng cross-platform với React Native.</p>\n</li>\n<li>\n<p><strong>Game</strong>: Game trên trình duyệt hoặc các nền tảng như Phaser.js.</p>\n</li>\n</ul>\n<h3>Vậy đâu là ngôn ngữ phù hợp với bạn?</h3>\n<ul data-spread=\"true\">\n<li>\n<p><strong>Chọn Java nếu</strong>:</p>\n<ul data-spread=\"false\">\n<li>\n<p>Bạn muốn xây dựng hệ thống backend lớn, đáng tin cậy.</p>\n</li>\n<li>\n<p>Bạn quan tâm đến phát triển ứng dụng di động (Android).</p>\n</li>\n<li>\n<p>Bạn yêu thích lập trình hướng đối tượng với cấu trúc chặt chẽ.</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Chọn JavaScript nếu</strong>:</p>\n<ul data-spread=\"false\">\n<li>\n<p>Bạn muốn làm việc với web, đặc biệt là frontend.</p>\n</li>\n<li>\n<p>Bạn yêu thích sự linh hoạt và nhanh chóng trong lập trình.</p>\n</li>\n<li>\n<p>Bạn quan tâm đến xây dựng ứng dụng cross-platform hoặc web động.</p>\n</li>\n</ul>\n</li>\n</ul>",
            "image": "https://tinpham231.github.io/gh-pages/media/posts/1/java-vs-nodejs.png",
            "author": {
                "name": "Pham Ba Tin"
            },
            "tags": [
                   "JavaScript",
                   "Java"
            ],
            "date_published": "2024-12-30T09:54:16+07:00",
            "date_modified": "2024-12-30T10:02:41+07:00"
        }
    ]
}
